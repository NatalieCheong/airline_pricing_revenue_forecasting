# -*- coding: utf-8 -*-
"""model_training.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hsks94vSpLa675tv4jlQi8cVNBnQUcrw
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler
import gc
import warnings
warnings.filterwarnings('ignore')

class AirlineForecaster:
    def __init__(self, target_type):
        """
        Initialize forecaster for specific prediction type
        target_type: 'no_show', 'cancellation', 'overbooking', or 'denied_boarding'
        """
        self.target_type = target_type
        self.model = None
        self.scaler = StandardScaler()
        self.feature_importance = None

    def extract_hour(self, time_str):
        """Safely extract hour from time string"""
        try:
            # Handle different time formats
            if ':' in str(time_str):
                return int(str(time_str).split(':')[0])
            return int(str(time_str)[:2])  # Take first two characters as hour
        except:
            return 12  # Default to noon if conversion fails

    def prepare_features(self, df):
        """Prepare features for model training"""
        print(f"\nPreparing features for {self.target_type} prediction...")

        # Create copy to avoid modifying original
        df = df.copy()

        # Convert date columns safely
        try:
            df['Dep_Date'] = pd.to_datetime(df['Dep_Date'])
            df['DayOfWeek'] = df['Dep_Date'].dt.dayofweek
            df['Month'] = df['Dep_Date'].dt.month

            # Extract hour safely
            df['Hour'] = df['Dep_time'].apply(self.extract_hour)

            # Create route feature
            df['Route'] = df['Origin'] + '_' + df['Destination']

            # Basic features
            feature_cols = ['DayOfWeek', 'Month', 'Hour', 'Booking Class Fare USD']

            # Add cabin class
            df['Cabin'] = df['Cabin'].fillna('Unknown')
            cabin_dummies = pd.get_dummies(df['Cabin'], prefix='Cabin')

            # Add booking class
            df['Booking Class'] = df['Booking Class'].fillna('Unknown')
            booking_dummies = pd.get_dummies(df['Booking Class'], prefix='Class')

            # Combine features
            X = pd.concat([
                df[feature_cols],
                cabin_dummies,
                booking_dummies
            ], axis=1)

            y = df[self.target_type]

            print(f"Number of features: {X.shape[1]}")
            print("Feature preparation completed successfully!")

            return X, y

        except Exception as e:
            print(f"Error in feature preparation: {str(e)}")
            raise

    def train_model(self, X_train, y_train):
        """Train Random Forest model"""
        print(f"\nTraining {self.target_type} prediction model...")

        self.model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,  # Limit depth to prevent overfitting
            min_samples_split=5,
            random_state=42,
            n_jobs=-1
        )

        self.model.fit(X_train, y_train)

        # Calculate feature importance
        self.feature_importance = pd.DataFrame({
            'feature': X_train.columns,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False)

        print("Model training completed!")

    def evaluate_model(self, X_test, y_test):
        """Evaluate model performance"""
        print(f"\nEvaluating {self.target_type} prediction model...")

        predictions = self.model.predict(X_test)

        mae = mean_absolute_error(y_test, predictions)
        mse = mean_squared_error(y_test, predictions)
        rmse = np.sqrt(mse)
        r2 = r2_score(y_test, predictions)

        print(f"Mean Absolute Error: {mae:.4f}")
        print(f"Root Mean Squared Error: {rmse:.4f}")
        print(f"RÂ² Score: {r2:.4f}")

        return predictions

    def plot_results(self, y_test, predictions):
        """Create visualizations for model results"""
        plt.figure(figsize=(15, 5))

        # Plot 1: Predicted vs Actual
        plt.subplot(1, 3, 1)
        plt.scatter(y_test, predictions, alpha=0.5)
        plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
        plt.xlabel('Actual Values')
        plt.ylabel('Predicted Values')
        plt.title(f'Actual vs Predicted {self.target_type.replace("_", " ").title()}')

        # Plot 2: Feature Importance
        plt.subplot(1, 3, 2)
        importance_data = self.feature_importance.head(10)
        sns.barplot(x='importance', y='feature', data=importance_data)
        plt.title('Top 10 Important Features')
        plt.xlabel('Feature Importance')

        # Plot 3: Prediction Error Distribution
        plt.subplot(1, 3, 3)
        error = y_test - predictions
        sns.histplot(error, kde=True)
        plt.title('Prediction Error Distribution')
        plt.xlabel('Prediction Error')

        plt.tight_layout()
        plt.show()

def train_specific_model(data_path, target_type):
    """Train and evaluate a specific type of model"""
    print(f"\n{'='*50}")
    print(f"Starting {target_type} prediction model training")
    print(f"{'='*50}")

    # Load data
    print("\nLoading data...")
    df = pd.read_csv(data_path)
    print(f"Dataset shape: {df.shape}")

    # Initialize forecaster
    forecaster = AirlineForecaster(target_type)

    try:
        # Prepare features
        X, y = forecaster.prepare_features(df)

        # Split data
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42
        )

        # Train model
        forecaster.train_model(X_train, y_train)

        # Evaluate model
        predictions = forecaster.evaluate_model(X_test, y_test)

        # Plot results
        forecaster.plot_results(y_test, predictions)

        # Clear memory
        gc.collect()

        return forecaster

    except Exception as e:
        print(f"Error in model training pipeline: {str(e)}")
        return None

def main():
    # File path
    data_path = 'forecasting_booking_12m.csv'

    # Train models for each type
    target_types = ['no_show', 'cancellation', 'overbooking', 'denied_boarding']
    models = {}

    for target_type in target_types:
        models[target_type] = train_specific_model(data_path, target_type)

        # Clear memory after each model
        gc.collect()
        plt.close('all')

    print("\nAll models have been trained and evaluated!")
    return models

if __name__ == "__main__":
    models = main()