# -*- coding: utf-8 -*-
"""revenue_optimization_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hsks94vSpLa675tv4jlQi8cVNBnQUcrw
"""

import pandas as pd
import numpy as np
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
warnings.filterwarnings('ignore')

class AirlineRevenueOptimizer:
    def __init__(self, data, capacity=400):
        """
        Initialize revenue optimizer

        Parameters:
        data: DataFrame with booking and forecasting data
        capacity: Aircraft capacity (default 400 seats)
        """
        self.data = data
        self.capacity = capacity
        self.booking_classes = self.data['Booking Class'].unique()

        # Calculate average fares by booking class
        self.class_fares = self.data.groupby('Booking Class')['Booking Class Fare USD'].mean()

        # Get predicted probabilities from our models
        self.no_show_probs = self.data['no_show']
        self.cancellation_probs = self.data['cancellation']
        self.overbooking_probs = self.data['overbooking']

    def analyze_class_metrics(self):
        """Analyze key metrics by booking class"""
        metrics = []

        for booking_class in self.booking_classes:
            class_data = self.data[self.data['Booking Class'] == booking_class]

            metrics.append({
                'Booking_Class': booking_class,
                'Avg_Fare': class_data['Booking Class Fare USD'].mean(),
                'No_Show_Rate': class_data['no_show'].mean(),
                'Cancellation_Rate': class_data['cancellation'].mean(),
                'Expected_Revenue_Per_Seat': class_data['Booking Class Fare USD'].mean() *
                                          (1 - class_data['no_show'].mean() -
                                           class_data['cancellation'].mean())
            })

        return pd.DataFrame(metrics)

    def optimize_seat_allocation(self):
        """Optimize seat allocation across booking classes"""
        class_metrics = self.analyze_class_metrics()

        # Initial allocation based on revenue potential
        total_revenue_potential = class_metrics['Expected_Revenue_Per_Seat'].sum()
        initial_allocation = {}

        for _, row in class_metrics.iterrows():
            revenue_share = row['Expected_Revenue_Per_Seat'] / total_revenue_potential
            initial_allocation[row['Booking_Class']] = int(self.capacity * revenue_share)

        # Adjust for overbooking
        overbooking_factor = 1 + self.data['overbooking'].mean()
        adjusted_capacity = int(self.capacity * overbooking_factor)

        # Calculate optimal allocation
        optimal_allocation = {}
        remaining_seats = adjusted_capacity

        # Sort classes by expected revenue per seat
        sorted_classes = class_metrics.sort_values('Expected_Revenue_Per_Seat', ascending=False)

        for _, row in sorted_classes.iterrows():
            booking_class = row['Booking_Class']
            base_allocation = initial_allocation[booking_class]

            # Adjust allocation based on no-show and cancellation rates
            no_show_rate = row['No_Show_Rate']
            cancellation_rate = row['Cancellation_Rate']

            # Calculate optimal allocation considering risk factors
            optimal_seats = int(base_allocation * (1 + no_show_rate + cancellation_rate))
            optimal_seats = min(optimal_seats, remaining_seats)

            optimal_allocation[booking_class] = optimal_seats
            remaining_seats -= optimal_seats

        return optimal_allocation

    def calculate_expected_revenue(self, allocation):
        """Calculate expected revenue for given seat allocation"""
        total_revenue = 0

        for booking_class, seats in allocation.items():
            class_data = self.data[self.data['Booking Class'] == booking_class]
            avg_fare = class_data['Booking Class Fare USD'].mean()
            show_rate = 1 - class_data['no_show'].mean() - class_data['cancellation'].mean()

            # Expected revenue = seats * fare * probability of showing up
            revenue = seats * avg_fare * show_rate
            total_revenue += revenue

        return total_revenue

    def suggest_dynamic_pricing(self):
        """Suggest dynamic pricing adjustments based on demand patterns"""
        class_metrics = self.analyze_class_metrics()
        pricing_suggestions = []

        for _, row in class_metrics.iterrows():
            base_fare = row['Avg_Fare']
            no_show_risk = row['No_Show_Rate']
            cancellation_risk = row['Cancellation_Rate']

            # Calculate risk-adjusted pricing factors
            peak_multiplier = 1 + (no_show_risk + cancellation_risk)
            off_peak_multiplier = 1 - (no_show_risk + cancellation_risk) / 2

            pricing_suggestions.append({
                'Booking_Class': row['Booking_Class'],
                'Base_Fare': base_fare,
                'Peak_Price': base_fare * peak_multiplier,
                'Off_Peak_Price': max(base_fare * off_peak_multiplier, base_fare * 0.7),
                'Risk_Factor': no_show_risk + cancellation_risk
            })

        return pd.DataFrame(pricing_suggestions)

    def visualize_optimization_results(self):
        """Visualize optimization results"""
        # Get optimized allocation
        allocation = self.optimize_seat_allocation()
        pricing = self.suggest_dynamic_pricing()

        # Create visualizations
        fig, axes = plt.subplots(2, 2, figsize=(20, 15))

        # 1. Seat Allocation
        pd.Series(allocation).plot(kind='bar', ax=axes[0,0])
        axes[0,0].set_title('Optimized Seat Allocation by Booking Class')
        axes[0,0].set_ylabel('Number of Seats')

        # 2. Expected Revenue by Class
        class_metrics = self.analyze_class_metrics()
        sns.barplot(data=class_metrics, x='Booking_Class', y='Expected_Revenue_Per_Seat',
                   ax=axes[0,1])
        axes[0,1].set_title('Expected Revenue per Seat by Booking Class')
        axes[0,1].set_ylabel('Revenue (USD)')

        # 3. Dynamic Pricing Range
        pricing.plot(x='Booking_Class', y=['Base_Fare', 'Peak_Price', 'Off_Peak_Price'],
                    kind='bar', ax=axes[1,0])
        axes[1,0].set_title('Dynamic Pricing Range by Booking Class')
        axes[1,0].set_ylabel('Fare (USD)')

        # 4. Risk Factor by Class
        sns.barplot(data=pricing, x='Booking_Class', y='Risk_Factor', ax=axes[1,1])
        axes[1,1].set_title('Risk Factor by Booking Class')
        axes[1,1].set_ylabel('Risk Factor (No-show + Cancellation Rate)')

        plt.tight_layout()
        plt.show()

        # Print summary statistics
        print("\nOPTIMIZATION SUMMARY")
        print("=" * 50)
        print(f"\nTotal Aircraft Capacity: {self.capacity}")
        print(f"Total Allocated Seats (with overbooking): {sum(allocation.values())}")
        print(f"Expected Total Revenue: ${self.calculate_expected_revenue(allocation):,.2f}")

        return allocation, pricing

def main():
    # Load the forecasting dataset
    print("Loading forecasting data...")
    df = pd.read_csv('forecasting_booking_12m.csv')

    # Initialize optimizer
    optimizer = AirlineRevenueOptimizer(df, capacity=400)

    # Run optimization and get results
    allocation, pricing = optimizer.visualize_optimization_results()

    # Print detailed recommendations
    print("\nDETAILED RECOMMENDATIONS")
    print("=" * 50)
    print("\n1. Seat Allocation Strategy:")
    for class_, seats in allocation.items():
        print(f"   • {class_}: {seats} seats")

    print("\n2. Dynamic Pricing Strategy:")
    for _, row in pricing.iterrows():
        print(f"\n   {row['Booking_Class']}:")
        print(f"   • Base Fare: ${row['Base_Fare']:.2f}")
        print(f"   • Peak Price: ${row['Peak_Price']:.2f}")
        print(f"   • Off-Peak Price: ${row['Off_Peak_Price']:.2f}")
        print(f"   • Risk Factor: {row['Risk_Factor']:.2%}")

if __name__ == "__main__":
    main()